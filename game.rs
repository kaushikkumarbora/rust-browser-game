#![no_main]
#![no_std]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_panic: &PanicInfo<'_>) -> ! {
    loop {}
}

const DISPLAY_WIDTH: usize = 800;
const DISPLAY_HEIGHT: usize = 600;
const DISPLAY_BACKGROUND: Pixel = Pixel::rgba(0x3F, 0x3F, 0x3F, 0xFF);
const PLAYER_SIZE: i32 = 80;
const PLAYER_COLOR: Pixel = Pixel::rgba(0xDF, 0xAF, 0x8F, 0xFF);
const PLAYER_KILL_REWARD: usize = 100;
const BULLET_SIZE: i32 = 25;
const BULLET_SPEED: i32 = 20;
const BULLET_COLOR: Pixel = Pixel::rgba(0xEC, 0xB3, 0xB3, 0xFF);
const ENEMY_SIZE: i32 = 100;
const ENEMY_COLOR: Pixel = Pixel::rgba(0x7C, 0xB8, 0xBB, 0xFF);
const ENEMY_SPEED: i32 = 5;
const BULLETS_CAPACITY: usize = 5;
const ENEMIES_CAPACITY: usize = 10;
const ENEMY_SPAWN_PERIOD: Seconds = 1.0;
const COMPRESSED_FONT: [u8; 1024] = [
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0xa1, 0x41, 0x0c, 0x0e, 0x08, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x20,
    0x00, 0x20, 0xa1, 0x43, 0xcc, 0x92, 0x08, 0x10, 0x21, 0x50, 0x80, 0x00, 0x00, 0x02, 0x44, 0x60,
    0x00, 0x20, 0x03, 0xe5, 0x01, 0x14, 0x00, 0x20, 0x10, 0xe0, 0x80, 0x00, 0x00, 0x04, 0x4c, 0xa0,
    0x00, 0x20, 0x01, 0x43, 0x82, 0x08, 0x00, 0x20, 0x11, 0xf3, 0xe0, 0x0f, 0x80, 0x08, 0x54, 0x20,
    0x00, 0x20, 0x03, 0xe1, 0x44, 0x15, 0x00, 0x20, 0x10, 0xe0, 0x81, 0x00, 0x00, 0x10, 0x64, 0x20,
    0x00, 0x00, 0x01, 0x47, 0x89, 0x92, 0x00, 0x10, 0x21, 0x50, 0x81, 0x00, 0x00, 0x20, 0x44, 0x20,
    0x00, 0x20, 0x01, 0x41, 0x01, 0x8d, 0x00, 0x08, 0x40, 0x00, 0x02, 0x00, 0x04, 0x00, 0x38, 0xf8,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x38, 0x70, 0x63, 0xe3, 0x8f, 0x8e, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0e, 0x1c, 0x78, 0x70,
    0x44, 0x88, 0xa2, 0x04, 0x00, 0x91, 0x22, 0x10, 0x20, 0x20, 0x02, 0x08, 0x91, 0x22, 0x44, 0x88,
    0x04, 0x09, 0x22, 0x04, 0x01, 0x11, 0x22, 0x00, 0x00, 0x43, 0xe1, 0x08, 0x97, 0x22, 0x44, 0x80,
    0x08, 0x31, 0xf3, 0xc7, 0x82, 0x0e, 0x1e, 0x00, 0x00, 0x80, 0x00, 0x81, 0x15, 0x3e, 0x78, 0x80,
    0x10, 0x08, 0x20, 0x24, 0x44, 0x11, 0x02, 0x00, 0x20, 0x43, 0xe1, 0x02, 0x17, 0x22, 0x44, 0x80,
    0x20, 0x88, 0x20, 0x24, 0x44, 0x11, 0x02, 0x10, 0x20, 0x20, 0x02, 0x00, 0x10, 0x22, 0x44, 0x88,
    0x7c, 0x70, 0x23, 0xc3, 0x84, 0x0e, 0x1c, 0x00, 0x40, 0x00, 0x00, 0x02, 0x0e, 0x22, 0x78, 0x70,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0xf9, 0xf1, 0xc4, 0x4f, 0x9f, 0x22, 0x40, 0x89, 0x11, 0xc7, 0x87, 0x1e, 0x1e, 0x7c, 0x88,
    0x44, 0x81, 0x02, 0x24, 0x42, 0x01, 0x22, 0x40, 0xd9, 0x12, 0x24, 0x48, 0x91, 0x20, 0x10, 0x88,
    0x44, 0x81, 0x02, 0x04, 0x42, 0x01, 0x24, 0x40, 0xa9, 0x92, 0x24, 0x48, 0x91, 0x20, 0x10, 0x88,
    0x44, 0xf1, 0xe2, 0x07, 0xc2, 0x01, 0x38, 0x40, 0x89, 0x52, 0x27, 0x88, 0x9e, 0x1c, 0x10, 0x88,
    0x44, 0x81, 0x02, 0x64, 0x42, 0x01, 0x24, 0x40, 0x89, 0x32, 0x24, 0x0a, 0x91, 0x02, 0x10, 0x88,
    0x44, 0x81, 0x02, 0x24, 0x42, 0x11, 0x22, 0x40, 0x89, 0x12, 0x24, 0x09, 0x11, 0x02, 0x10, 0x88,
    0x78, 0xf9, 0x01, 0xc4, 0x4f, 0x8e, 0x22, 0x7c, 0x89, 0x11, 0xc4, 0x06, 0x91, 0x3c, 0x10, 0x70,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x44, 0x89, 0x12, 0x27, 0xc3, 0x00, 0x18, 0x10, 0x00, 0x80, 0x04, 0x00, 0x01, 0x00, 0x18, 0x00,
    0x44, 0x89, 0x12, 0x20, 0x42, 0x10, 0x08, 0x28, 0x00, 0x40, 0x04, 0x00, 0x01, 0x00, 0x20, 0x00,
    0x44, 0x88, 0xa1, 0x40, 0x82, 0x08, 0x08, 0x00, 0x00, 0x01, 0xc7, 0x87, 0x0f, 0x1c, 0x7c, 0x78,
    0x44, 0x88, 0x40, 0x81, 0x02, 0x04, 0x08, 0x00, 0x00, 0x00, 0x24, 0x48, 0x91, 0x22, 0x20, 0x88,
    0x44, 0xa8, 0xa0, 0x82, 0x02, 0x02, 0x08, 0x00, 0x00, 0x01, 0xe4, 0x48, 0x11, 0x3e, 0x20, 0x78,
    0x28, 0xd9, 0x10, 0x84, 0x02, 0x01, 0x08, 0x00, 0x00, 0x02, 0x24, 0x48, 0x91, 0x20, 0x20, 0x08,
    0x10, 0x89, 0x10, 0x87, 0xc3, 0x00, 0x18, 0x00, 0xf8, 0x01, 0xe7, 0x87, 0x0f, 0x1e, 0x20, 0x70,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x20, 0x12, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0xe0, 0x72, 0x44, 0x0d, 0x1e, 0x1c, 0x78, 0x79, 0x61, 0xe7, 0x88, 0x91, 0x22, 0x44, 0x88,
    0x44, 0x20, 0x13, 0x84, 0x0a, 0x91, 0x22, 0x44, 0x89, 0x92, 0x02, 0x08, 0x91, 0x22, 0x28, 0x88,
    0x44, 0x20, 0x12, 0x44, 0x0a, 0x91, 0x22, 0x78, 0x79, 0x01, 0xc2, 0x08, 0x91, 0x22, 0x10, 0x78,
    0x44, 0x21, 0x12, 0x24, 0x08, 0x91, 0x22, 0x40, 0x09, 0x00, 0x22, 0x48, 0x8a, 0x2a, 0x28, 0x08,
    0x44, 0xf8, 0xe2, 0x23, 0x88, 0x91, 0x1c, 0x40, 0x09, 0x03, 0xc1, 0x87, 0x84, 0x14, 0x44, 0x70,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7c, 0x20, 0x40, 0x82, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x40, 0x40, 0x45, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7c, 0x10, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

#[derive(Clone, Copy)]
#[repr(C)]
struct Pixel(u32);

impl Pixel {
    const fn rgba(r: u8, g: u8, b: u8, a: u8) -> Self {
        Self(
            ((a as u32) << (3 * 8))
                | ((b as u32) << (2 * 8))
                | ((g as u32) << (1 * 8))
                | ((r as u32) << (0 * 8)),
        )
    }
}

#[repr(C)]
pub struct Display {
    pixels: [Pixel; DISPLAY_WIDTH * DISPLAY_HEIGHT],
}

const fn max(x: i32, y: i32) -> i32 {
    if x > y {
        x
    } else {
        y
    }
}

const fn min(x: i32, y: i32) -> i32 {
    if x < y {
        x
    } else {
        y
    }
}

const fn clamp(x: i32, low: i32, high: i32) -> i32 {
    min(max(low, x), high)
}

impl Display {
    fn fill(&mut self, pixel: Pixel) {
        unsafe {
            for y in 0..DISPLAY_HEIGHT {
                for x in 0..DISPLAY_WIDTH {
                    *self.pixels.get_unchecked_mut(y * DISPLAY_WIDTH + x) = pixel;
                }
            }
        }
    }

    fn fill_rect(&mut self, x0: i32, y0: i32, w: i32, h: i32, pixel: Pixel) {
        let x1 = clamp(x0, 0, (DISPLAY_WIDTH - 1) as i32) as usize;
        let x2 = clamp(x0 + w - 1, 0, (DISPLAY_WIDTH - 1) as i32) as usize;
        let y1 = clamp(y0, 0, (DISPLAY_HEIGHT - 1) as i32) as usize;
        let y2 = clamp(y0 + h - 1, 0, (DISPLAY_HEIGHT - 1) as i32) as usize;

        unsafe {
            for y in y1..=y2 {
                for x in x1..=x2 {
                    *self.pixels.get_unchecked_mut(y * DISPLAY_WIDTH + x) = pixel;
                }
            }
        }
    }
}

type Seconds = f32;

#[derive(Copy, Clone)]
#[repr(C)]
struct Entity {
    x: i32,
    y: i32,
    alive: bool,
}

impl Entity {
    const fn new(x: i32, y: i32) -> Self {
        Self { x, y, alive: true }
    }

    const fn dead() -> Self {
        Self {
            x: 0,
            y: 0,
            alive: false,
        }
    }

    fn revive(&mut self, x: i32, y: i32) {
        self.alive = true;
        self.x = x;
        self.y = y;
    }

    fn render(&self, display: &mut Display, size: i32, color: Pixel) {
        if self.alive {
            display.fill_rect(self.x - size / 2, self.y - size / 2, size, size, color);
        }
    }

    fn overlaps(&self, self_size: i32, that: &Self, that_size: i32) -> bool {
        let left1 = self.x - self_size / 2;
        let right1 = self.x + self_size / 2;
        let top1 = self.y - self_size / 2;
        let bottom1 = self.y + self_size / 2;

        let left2 = that.x - that_size / 2;
        let right2 = that.x + that_size / 2;
        let top2 = that.y - that_size / 2;
        let bottom2 = that.y + that_size / 2;

        right1 >= left2 && right2 >= left1 && bottom2 >= top1 && bottom1 >= top2
    }
}

const IMAGE_WIDTH: usize = 128;
const IMAGE_HEIGHT: usize = 64;
const CHUNK_SIZE: usize = 8;
const CHUNK_COUNT: usize = IMAGE_WIDTH * IMAGE_HEIGHT / CHUNK_SIZE;

struct Font {
    pixels: [u8; IMAGE_WIDTH * IMAGE_HEIGHT],
}

impl Font {
    fn decompress_from_bytes(&mut self, chunks: &[u8; CHUNK_COUNT]) {
        for chunk_index in 0..CHUNK_COUNT {
            let chunk = chunks[chunk_index as usize];
            for bit_index in 0..CHUNK_SIZE {
                self.pixels[chunk_index * CHUNK_SIZE + bit_index] =
                    ((chunk >> (CHUNK_SIZE - bit_index - 1)) & 1) * 0xFF;
            }
        }
    }
}

#[repr(C)]
pub struct State {
    player: Entity,
    bullets: [Entity; BULLETS_CAPACITY],
    enemies: [Entity; ENEMIES_CAPACITY],
    enemy_spawn_cooldown: Seconds,
    pause: bool,
    score: usize,
}

impl State {
    const fn default() -> Self {
        Self {
            player: Entity::new(0, DISPLAY_HEIGHT as i32 - PLAYER_SIZE),
            bullets: [Entity::dead(); BULLETS_CAPACITY],
            enemies: [Entity::dead(); ENEMIES_CAPACITY],
            enemy_spawn_cooldown: 0.0,
            pause: false,
            score: 0,
        }
    }

    fn update(&mut self, dt: Seconds) {
        if !self.pause {
            for bullet in self.bullets.iter_mut() {
                if bullet.alive {
                    bullet.y -= BULLET_SPEED;
                    if bullet.y < 0 {
                        bullet.alive = false
                    }
                }
            }
            for enemy in self.enemies.iter_mut() {
                if enemy.alive {
                    enemy.y += ENEMY_SPEED;
                    if enemy.y > DISPLAY_HEIGHT as i32 {
                        enemy.alive = false
                    }
                }
            }

            for enemy in self.enemies.iter_mut() {
                if enemy.alive {
                    for bullet in self.bullets.iter_mut() {
                        if bullet.alive {
                            if enemy.overlaps(ENEMY_SIZE, bullet, BULLET_SIZE) {
                                enemy.alive = false;
                                bullet.alive = false;
                                self.score += PLAYER_KILL_REWARD;
                                break;
                            }
                        }
                    }
                }

                // Enemy could be killed by the bullet in the previous
                // condition. So we need to check if it's alive again.
                if enemy.alive {
                    if enemy.overlaps(ENEMY_SIZE, &self.player, PLAYER_SIZE) {
                        self.player.alive = false;
                    }
                }
            }

            self.enemy_spawn_cooldown -= dt;
            if self.enemy_spawn_cooldown < 0.0 {
                self.spawn_enemy(self.player.x, 0);
                self.enemy_spawn_cooldown = ENEMY_SPAWN_PERIOD;
            }
        }
    }

    fn render(&self, display: &mut Display, font: &Font) {
        if !self.pause {
            display.fill(Pixel::rgba(font.pixels[0], 0, 0, 0));
            self.player.render(display, PLAYER_SIZE, PLAYER_COLOR);
            for bullet in self.bullets.iter() {
                bullet.render(display, BULLET_SIZE, BULLET_COLOR)
            }
            for enemy in self.enemies.iter() {
                enemy.render(display, ENEMY_SIZE, ENEMY_COLOR)
            }
        }
    }

    fn spawn_enemy(&mut self, x: i32, y: i32) {
        for enemy in self.enemies.iter_mut() {
            if !enemy.alive {
                enemy.revive(x, y);
                break;
            }
        }
    }

    fn spawn_bullet(&mut self, x: i32, y: i32) {
        for bullet in self.bullets.iter_mut() {
            if !bullet.alive {
                bullet.revive(x, y);
                break;
            }
        }
    }

    fn mouse_move(&mut self, x: i32, _y: i32) {
        if self.player.alive {
            self.player.x = x;
        }
    }

    fn mouse_click(&mut self) {
        if self.player.alive {
            self.spawn_bullet(
                self.player.x,
                self.player.y - PLAYER_SIZE / 2 - BULLET_SIZE / 2,
            );
        }
    }

    fn toggle_pause(&mut self) {
        self.pause = !self.pause
    }
}

static mut FONT: Font = Font {
    pixels: [0; 1024 * 8],
};
static mut STATE: State = State::default();
static mut DISPLAY: Display = Display {
    pixels: [Pixel(0); DISPLAY_WIDTH * DISPLAY_HEIGHT],
};


#[no_mangle]
pub unsafe fn init() {
    FONT.decompress_from_bytes(&COMPRESSED_FONT);
}

#[no_mangle]
pub fn get_display_width() -> usize {
    DISPLAY_WIDTH
}

#[no_mangle]
pub fn get_display_height() -> usize {
    DISPLAY_HEIGHT
}

#[no_mangle]
pub unsafe fn get_display() -> &'static mut Display {
    &mut DISPLAY
}

#[no_mangle]
pub unsafe fn next_frame(dt: Seconds) {
    STATE.update(dt);
    STATE.render(&mut DISPLAY, &FONT);
}

#[no_mangle]
pub unsafe fn mouse_move(x: i32, y: i32) {
    STATE.mouse_move(x, y);
}

#[no_mangle]
pub unsafe fn mouse_click() {
    STATE.mouse_click();
}

#[no_mangle]
pub unsafe fn toggle_pause() {
    STATE.toggle_pause();
}

#[allow(dead_code)]
extern "C" {
    fn js_sin(x: f32) -> f32;
    fn js_cos(x: f32) -> f32;
}
